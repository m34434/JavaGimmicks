package net.sf.javagimmicks.concurrent.locks;

import java.util.Collection;
import java.util.concurrent.locks.Lock;

/**
 * An extension of {@link Lock} that allows atomic locking on any number of
 * resources (which can be identified by resource identifiers).
 * <p>
 * Instances can only be retrieve from a {@link MultiReadWriteLock} instance
 * which in turn must be generated by a {@link MultiLockProvider} (which also
 * takes care about resource identifier management).
 * 
 * @param <K>
 *           The type of the internally used resource identifiers
 * @see MultiReadWriteLock#readLock()
 * @see MultiReadWriteLock#writeLock()
 * @see MultiLockProvider#newLock(Collection)
 */
public interface MultiLock<K> extends Lock
{
   /**
    * Returns the resource identifiers with which this instance is associated.
    * 
    * @return the resource identifiers with which this instance is associated.
    */
   public Collection<K> getResourceIds();

   /**
    * Returns if the current {@link Thread} holds this {@link MultiLock}.
    * 
    * @return if the current {@link Thread} holds this {@link MultiLock}
    */
   public boolean isLockedByThisThread();
}
